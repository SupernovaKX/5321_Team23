{"ast":null,"code":"// src/services/crypto.js\n\n/**\n * 端到端加密文件分享系统的加密服务\n * 使用Web Crypto API实现AES-GCM加密\n */\n\n// 生成随机密码供加密使用\nexport const generatePassword = (length = 24) => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+';\n  const randomValues = new Uint8Array(length);\n  window.crypto.getRandomValues(randomValues);\n  let password = '';\n  for (let i = 0; i < length; i++) {\n    password += chars.charAt(randomValues[i] % chars.length);\n  }\n  return password;\n};\n\n// 从密码派生加密密钥\nexport const deriveKey = async password => {\n  // 将密码转换为 UTF-8 编码的 ArrayBuffer\n  const encoder = new TextEncoder();\n  const passwordBuffer = encoder.encode(password);\n\n  // 导入密码作为原始密钥材料\n  const importedKey = await window.crypto.subtle.importKey('raw', passwordBuffer, {\n    name: 'PBKDF2'\n  }, false, ['deriveKey']);\n\n  // 创建盐值 (salt)\n  const salt = window.crypto.getRandomValues(new Uint8Array(16));\n\n  // 使用PBKDF2从密码派生AES-GCM密钥\n  const derivedKey = await window.crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt,\n    iterations: 100000,\n    hash: 'SHA-256'\n  }, importedKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, true, ['encrypt', 'decrypt']);\n  return {\n    key: derivedKey,\n    salt\n  };\n};\n\n// 加密文件\nexport const encryptFile = async (file, password) => {\n  // 生成加密密钥和初始化向量\n  const {\n    key,\n    salt\n  } = await deriveKey(password);\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n\n  // 读取文件内容\n  const fileBuffer = await file.arrayBuffer();\n\n  // 使用AES-GCM加密文件\n  const encryptedBuffer = await window.crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, fileBuffer);\n\n  // 创建包含所有必要数据的结果对象\n  const encryptedFile = new Blob([encryptedBuffer], {\n    type: 'application/octet-stream'\n  });\n\n  // 导出密钥以便后续解密\n  const exportedKeyBuffer = await window.crypto.subtle.exportKey('raw', key);\n\n  // 返回加密文件和解密所需的元数据\n  return {\n    encryptedFile,\n    metadata: {\n      salt: Array.from(salt),\n      iv: Array.from(iv),\n      originalName: file.name,\n      originalType: file.type,\n      originalSize: file.size\n    }\n  };\n};\n\n// 解密文件\nexport const decryptFile = async (encryptedFile, metadata, password) => {\n  const {\n    salt,\n    iv,\n    originalName,\n    originalType\n  } = metadata;\n\n  // 重新创建密钥\n  const encoder = new TextEncoder();\n  const passwordBuffer = encoder.encode(password);\n\n  // 导入密码作为原始密钥材料\n  const importedKey = await window.crypto.subtle.importKey('raw', passwordBuffer, {\n    name: 'PBKDF2'\n  }, false, ['deriveKey']);\n\n  // 使用相同的盐值和迭代次数派生相同的密钥\n  const derivedKey = await window.crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt: new Uint8Array(salt),\n    iterations: 100000,\n    hash: 'SHA-256'\n  }, importedKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, false, ['decrypt']);\n\n  // 读取加密文件内容\n  const encryptedBuffer = await encryptedFile.arrayBuffer();\n\n  // 使用AES-GCM解密文件\n  try {\n    const decryptedBuffer = await window.crypto.subtle.decrypt({\n      name: 'AES-GCM',\n      iv: new Uint8Array(iv)\n    }, derivedKey, encryptedBuffer);\n\n    // 创建解密后的文件Blob，恢复原始文件类型\n    const decryptedFile = new Blob([decryptedBuffer], {\n      type: originalType || 'application/octet-stream'\n    });\n    return {\n      file: decryptedFile,\n      fileName: originalName\n    };\n  } catch (error) {\n    throw new Error('解密失败！请检查密码是否正确。');\n  }\n};","map":{"version":3,"names":["generatePassword","length","chars","randomValues","Uint8Array","window","crypto","getRandomValues","password","i","charAt","deriveKey","encoder","TextEncoder","passwordBuffer","encode","importedKey","subtle","importKey","name","salt","derivedKey","iterations","hash","key","encryptFile","file","iv","fileBuffer","arrayBuffer","encryptedBuffer","encrypt","encryptedFile","Blob","type","exportedKeyBuffer","exportKey","metadata","Array","from","originalName","originalType","originalSize","size","decryptFile","decryptedBuffer","decrypt","decryptedFile","fileName","error","Error"],"sources":["/Users/yangkexin/Documents/CS5321/Group_project/End_to_end_encryption_file_/src/services/crypto.js"],"sourcesContent":["// src/services/crypto.js\n\n/**\n * 端到端加密文件分享系统的加密服务\n * 使用Web Crypto API实现AES-GCM加密\n */\n\n// 生成随机密码供加密使用\nexport const generatePassword = (length = 24) => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+';\n  const randomValues = new Uint8Array(length);\n  window.crypto.getRandomValues(randomValues);\n  \n  let password = '';\n  for (let i = 0; i < length; i++) {\n    password += chars.charAt(randomValues[i] % chars.length);\n  }\n  return password;\n};\n\n// 从密码派生加密密钥\nexport const deriveKey = async (password) => {\n  // 将密码转换为 UTF-8 编码的 ArrayBuffer\n  const encoder = new TextEncoder();\n  const passwordBuffer = encoder.encode(password);\n  \n  // 导入密码作为原始密钥材料\n  const importedKey = await window.crypto.subtle.importKey(\n    'raw',\n    passwordBuffer,\n    { name: 'PBKDF2' },\n    false,\n    ['deriveKey']\n  );\n  \n  // 创建盐值 (salt)\n  const salt = window.crypto.getRandomValues(new Uint8Array(16));\n  \n  // 使用PBKDF2从密码派生AES-GCM密钥\n  const derivedKey = await window.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations: 100000,\n      hash: 'SHA-256'\n    },\n    importedKey,\n    { name: 'AES-GCM', length: 256 },\n    true,\n    ['encrypt', 'decrypt']\n  );\n  \n  return { key: derivedKey, salt };\n};\n\n// 加密文件\nexport const encryptFile = async (file, password) => {\n  // 生成加密密钥和初始化向量\n  const { key, salt } = await deriveKey(password);\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  \n  // 读取文件内容\n  const fileBuffer = await file.arrayBuffer();\n  \n  // 使用AES-GCM加密文件\n  const encryptedBuffer = await window.crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv\n    },\n    key,\n    fileBuffer\n  );\n  \n  // 创建包含所有必要数据的结果对象\n  const encryptedFile = new Blob([encryptedBuffer], { type: 'application/octet-stream' });\n  \n  // 导出密钥以便后续解密\n  const exportedKeyBuffer = await window.crypto.subtle.exportKey('raw', key);\n  \n  // 返回加密文件和解密所需的元数据\n  return {\n    encryptedFile,\n    metadata: {\n      salt: Array.from(salt),\n      iv: Array.from(iv),\n      originalName: file.name,\n      originalType: file.type,\n      originalSize: file.size\n    }\n  };\n};\n\n// 解密文件\nexport const decryptFile = async (encryptedFile, metadata, password) => {\n  const { salt, iv, originalName, originalType } = metadata;\n  \n  // 重新创建密钥\n  const encoder = new TextEncoder();\n  const passwordBuffer = encoder.encode(password);\n  \n  // 导入密码作为原始密钥材料\n  const importedKey = await window.crypto.subtle.importKey(\n    'raw',\n    passwordBuffer,\n    { name: 'PBKDF2' },\n    false,\n    ['deriveKey']\n  );\n  \n  // 使用相同的盐值和迭代次数派生相同的密钥\n  const derivedKey = await window.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt: new Uint8Array(salt),\n      iterations: 100000,\n      hash: 'SHA-256'\n    },\n    importedKey,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['decrypt']\n  );\n  \n  // 读取加密文件内容\n  const encryptedBuffer = await encryptedFile.arrayBuffer();\n  \n  // 使用AES-GCM解密文件\n  try {\n    const decryptedBuffer = await window.crypto.subtle.decrypt(\n      {\n        name: 'AES-GCM',\n        iv: new Uint8Array(iv)\n      },\n      derivedKey,\n      encryptedBuffer\n    );\n    \n    // 创建解密后的文件Blob，恢复原始文件类型\n    const decryptedFile = new Blob([decryptedBuffer], { type: originalType || 'application/octet-stream' });\n    \n    return {\n      file: decryptedFile,\n      fileName: originalName\n    };\n  } catch (error) {\n    throw new Error('解密失败！请检查密码是否正确。');\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}