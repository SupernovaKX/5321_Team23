{"ast":null,"code":"'use strict';\n\nconst defaultIsExtractableFile = require('./isExtractableFile.js');\n\n/**\n * Clones a value, recursively extracting\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File),\n * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) and\n * [`ReactNativeFile`]{@link ReactNativeFile} instances with their\n * [object paths]{@link ObjectPath}, replacing them with `null`.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist) instances\n * are treated as [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)\n * instance arrays.\n * @kind function\n * @name extractFiles\n * @param {*} value Value (typically an object tree) to extract files from.\n * @param {ObjectPath} [path=''] Prefix for object paths for extracted files.\n * @param {ExtractableFileMatcher} [isExtractableFile=isExtractableFile] The function used to identify extractable files.\n * @returns {ExtractFilesResult} Result.\n * @example <caption>Ways to `import`.</caption>\n * ```js\n * import { extractFiles } from 'extract-files';\n * ```\n *\n * ```js\n * import extractFiles from 'extract-files/public/extractFiles.js';\n * ```\n * @example <caption>Ways to `require`.</caption>\n * ```js\n * const { extractFiles } = require('extract-files');\n * ```\n *\n * ```js\n * const extractFiles = require('extract-files/public/extractFiles.js');\n * ```\n * @example <caption>Extract files from an object.</caption>\n * For the following:\n *\n * ```js\n * const file1 = new File(['1'], '1.txt', { type: 'text/plain' });\n * const file2 = new File(['2'], '2.txt', { type: 'text/plain' });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, 'prefix');\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `['prefix.a', 'prefix.b.0']` |\n * | `file2` | `['prefix.b.1']`             |\n */\nmodule.exports = function extractFiles(value, path = '', isExtractableFile = defaultIsExtractableFile) {\n  // Map of extracted files and their object paths within the input value.\n  const files = new Map();\n\n  // Map of arrays and objects recursed within the input value and their clones,\n  // for reusing clones of values that are referenced multiple times within the\n  // input value.\n  const clones = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @kind function\n   * @name extractFiles~recurse\n   * @param {*} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set} recursed Recursed arrays and objects for avoiding infinite recursion of circular references within the input value.\n   * @returns {*} Clone of the value with files replaced with `null`.\n   * @ignore\n   */\n  function recurse(value, path, recursed) {\n    let clone = value;\n    if (isExtractableFile(value)) {\n      clone = null;\n      const filePaths = files.get(value);\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n    } else {\n      const isList = Array.isArray(value) || typeof FileList !== 'undefined' && value instanceof FileList;\n      const isObject = value && value.constructor === Object;\n      if (isList || isObject) {\n        const hasClone = clones.has(value);\n        if (hasClone) clone = clones.get(value);else {\n          clone = isList ? [] : {};\n          clones.set(value, clone);\n        }\n        if (!recursed.has(value)) {\n          const pathPrefix = path ? `${path}.` : '';\n          const recursedDeeper = new Set(recursed).add(value);\n          if (isList) {\n            let index = 0;\n            for (const item of value) {\n              const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);\n              if (!hasClone) clone.push(itemClone);\n            }\n          } else for (const key in value) {\n            const propertyClone = recurse(value[key], pathPrefix + key, recursedDeeper);\n            if (!hasClone) clone[key] = propertyClone;\n          }\n        }\n      }\n    }\n    return clone;\n  }\n  return {\n    clone: recurse(value, path, new Set()),\n    files\n  };\n};","map":{"version":3,"names":["defaultIsExtractableFile","require","module","exports","extractFiles","value","path","isExtractableFile","files","Map","clones","recurse","recursed","clone","filePaths","get","push","set","isList","Array","isArray","FileList","isObject","constructor","Object","hasClone","has","pathPrefix","recursedDeeper","Set","add","index","item","itemClone","key","propertyClone"],"sources":["/Users/yangkexin/Documents/CS5321/Group_project/End_to_end_encryption_file_/node_modules/extract-files/public/extractFiles.js"],"sourcesContent":["'use strict';\n\nconst defaultIsExtractableFile = require('./isExtractableFile.js');\n\n/**\n * Clones a value, recursively extracting\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File),\n * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) and\n * [`ReactNativeFile`]{@link ReactNativeFile} instances with their\n * [object paths]{@link ObjectPath}, replacing them with `null`.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist) instances\n * are treated as [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)\n * instance arrays.\n * @kind function\n * @name extractFiles\n * @param {*} value Value (typically an object tree) to extract files from.\n * @param {ObjectPath} [path=''] Prefix for object paths for extracted files.\n * @param {ExtractableFileMatcher} [isExtractableFile=isExtractableFile] The function used to identify extractable files.\n * @returns {ExtractFilesResult} Result.\n * @example <caption>Ways to `import`.</caption>\n * ```js\n * import { extractFiles } from 'extract-files';\n * ```\n *\n * ```js\n * import extractFiles from 'extract-files/public/extractFiles.js';\n * ```\n * @example <caption>Ways to `require`.</caption>\n * ```js\n * const { extractFiles } = require('extract-files');\n * ```\n *\n * ```js\n * const extractFiles = require('extract-files/public/extractFiles.js');\n * ```\n * @example <caption>Extract files from an object.</caption>\n * For the following:\n *\n * ```js\n * const file1 = new File(['1'], '1.txt', { type: 'text/plain' });\n * const file2 = new File(['2'], '2.txt', { type: 'text/plain' });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, 'prefix');\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `['prefix.a', 'prefix.b.0']` |\n * | `file2` | `['prefix.b.1']`             |\n */\nmodule.exports = function extractFiles(\n  value,\n  path = '',\n  isExtractableFile = defaultIsExtractableFile\n) {\n  // Map of extracted files and their object paths within the input value.\n  const files = new Map();\n\n  // Map of arrays and objects recursed within the input value and their clones,\n  // for reusing clones of values that are referenced multiple times within the\n  // input value.\n  const clones = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @kind function\n   * @name extractFiles~recurse\n   * @param {*} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set} recursed Recursed arrays and objects for avoiding infinite recursion of circular references within the input value.\n   * @returns {*} Clone of the value with files replaced with `null`.\n   * @ignore\n   */\n  function recurse(value, path, recursed) {\n    let clone = value;\n\n    if (isExtractableFile(value)) {\n      clone = null;\n\n      const filePaths = files.get(value);\n\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n    } else {\n      const isList =\n        Array.isArray(value) ||\n        (typeof FileList !== 'undefined' && value instanceof FileList);\n      const isObject = value && value.constructor === Object;\n\n      if (isList || isObject) {\n        const hasClone = clones.has(value);\n\n        if (hasClone) clone = clones.get(value);\n        else {\n          clone = isList ? [] : {};\n\n          clones.set(value, clone);\n        }\n\n        if (!recursed.has(value)) {\n          const pathPrefix = path ? `${path}.` : '';\n          const recursedDeeper = new Set(recursed).add(value);\n\n          if (isList) {\n            let index = 0;\n\n            for (const item of value) {\n              const itemClone = recurse(\n                item,\n                pathPrefix + index++,\n                recursedDeeper\n              );\n\n              if (!hasClone) clone.push(itemClone);\n            }\n          } else\n            for (const key in value) {\n              const propertyClone = recurse(\n                value[key],\n                pathPrefix + key,\n                recursedDeeper\n              );\n\n              if (!hasClone) clone[key] = propertyClone;\n            }\n        }\n      }\n    }\n\n    return clone;\n  }\n\n  return {\n    clone: recurse(value, path, new Set()),\n    files,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}